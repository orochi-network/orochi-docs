---
description: >-
  In this page, we're going to describe the process that allows a group of
  participants to generate the grand randomness of an epoch.
---

# ðŸ¤– Protocol

## Epoch

Assuming that we have $$n$$ participants denote $$P_1, P_2, ... P_n$$. Each participant play two roles in our system **dealer** and **verifier**. Each participant $$P_i$$ have their own key-pair $$\{SK_i,PK_i\}$$ and the public key $$PK_i$$ is available to all other participants.

### Draw Phase

All participants $$P_i$$ will need to generate their secret and also a randomness by using VRF with $$x$$ is the grand randomness of previous epoch. In the genesis epoch $$x$$ can be generated by combining participants's hash of public keys.

We have $$x_0$$ at genesis epoch:

$$
x_0=H(PK_1) \oplus H(PK_2) \oplus ... \oplus H(PK_i)
$$

For another epoch we have:

$$
\{r_i,\pi_x\}=f_{SK}(x)
$$

### Split Phase

$$P_i$$ _(is also know as dealer_ $$D_i$$_)_ will split their $$r_i$$ into shares $$\{s_{i1}, s_{i2},...,s_{in}\}$$, all other participants need $$t$$ shares to reconstruct $$r_i$$, $$0 \leq t \leq n$$. In our protocol we choose $$\frac{n}{2} < t < \frac{3n}{4}$$

Each participant can forge their message $$M_{s_{ij}}$$ corresponding to the share $$s_{ij}$$ and distribute to other participants _(is also know as verifier_ $$V_i$$_)._

$$
M_{ij}=E_{ij}(s_{ij}){+\!\!\!\!+\,}Proof_{P_i}
$$

### Gossip Phase

To prevent the participant $$P_i$$ to deal all of his shares to his colluding party. We require all participant to draw distribution param $$q_i$$ by using VRF, each epoch will have different $$q_i$$.

$$
\{q_i,\pi_{H(x)}\} = f_{SK_i}(H(x))
$$

We assume that node id of participant is the digest of their public key

$$
N_i=H(PK_i)
$$

We have, share distribution $$Q_{ij}$$ of $$s_{ij}$$ is:

$$
Q_{ij} = H(q_i{+\!\!\!\!+\,}j)
$$

Assume $$d_{ij}(N_i)=N_i \oplus Q_{ij}$$ is the distance between node id and share distribution. We will distribute the share corresponding $$s_{ij}$$ to the node which have closest node id to $$Q_{ij}$$. By using repeating this method, we can multicast the shares to all nodes in the network randomly, this process is transparent and verifiable for all participants.

### Virtual Voting Phase

> **Note:** We need to calculate the duration that is necessary for virtual voting to reach an agreement

Virtual voting isn't actual voting, it is the assumption of participants based on its knowledge. The gossip process will grow the knowledge of all participants and it will guarantee that the shares of randomness will increasing over the time for each participant.

### Audit Phase

> **Note:** We need using one-way payment enforcing penalty to cheaters.

In case there are some dishonest participants based on current state of all nodes, any one can asked dishonest participant to commit missing shares. If the share wasn't committed after the audit phase, the penalty will be applied to the dishonest participants.

> **Note:** We might need Zero Knowledge Proof to improve the performance of Audit Phase

### Conclusion Phase

#### Happy ending

> **Note:** We need more research on threshold signature and multi-party computation

All participants $$P_i$$ commit all their shares and any on them could reconstruct $$\{r_1, r_2,...,r_i\}$$ and the grant randomness will be call curated

$$
R = r_1 \oplus r_2 \oplus ... \oplus r_i
$$

The last process is all participant need to reach the agreement to use threshold signing and multi-party computation to commit the result to blockchain.

#### Bad ending

Not enough shares to reconstruct randomness by any participants, in this case all participant might loss their collateral.
